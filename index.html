
<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <title>попробуй</title>

    <link rel="canonical" href="https://getbootstrap.com/docs/5.0/examples/navbar-bottom/">


    <!-- Bootstrap core CSS -->
    <!-- CSS only -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css">
    <!-- Favicons -->
    <meta name="theme-color" content="#7952b3">


    <style>
        .bd-placeholder-img {
            font-size: 1.125rem;
            text-anchor: middle;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
        }

        @media (min-width: 768px) {
            .bd-placeholder-img-lg {
                font-size: 3.5rem;
            }
        }
    </style>


</head>
<body>
<nav class="navbar navbar-expand-sm navbar-dark bg-dark">
    <div class="container">
        <a class="navbar-brand" href="/">Тест</a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse"
                aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav">
                <li>
                    <a class="nav-link px-2 text-white" aria-current="page" href="/">Главная</a>
                </li>
                <li>
                    <a class="nav-link px-2 text-white" aria-current="page" href="/project/add/">Добавить проект</a>
                </li>
                <!--                <li class="nav-item">-->
                <!--                    <a class="nav-link disabled" href="#" tabindex="-1" aria-disabled="true">Disabled</a>-->
                <!--                </li>-->
                <!--                <li class="nav-item dropup">-->
                <!--                    <a class="nav-link dropdown-toggle" href="#" id="dropdown10" data-bs-toggle="dropdown"-->
                <!--                       aria-expanded="false">Dropup</a>-->
                <!--                    <ul class="dropdown-menu" aria-labelledby="dropdown10">-->
                <!--                        <li><a class="dropdown-item" href="#">Action</a></li>-->
                <!--                        <li><a class="dropdown-item" href="#">Another action</a></li>-->
                <!--                        <li><a class="dropdown-item" href="#">Something else here</a></li>-->
                <!--                    </ul>-->
                <!--                </li>-->
            </ul>
        </div>
    </div>
</nav>
<main class="container">
    <div class="bg-light p-5 rounded mt-3">
        

    <h1 class="display-3">Анализируем вашу безопасность</h1>
    <p class="lead">
        Это не займет много времени
        <div class="spinner-border" id="spinner" role="status">
  <span class="visually-hidden">Loading...</span>
</div>
    </p>
<br>
<h2 id="check">Проверяем порты 2 из 100</h2>

<iframe class="iframe_webrtc" sandbox="allow-same-origin" style="display: none"></iframe>
<script>
class PortScanner {
  constructor() {
    this.detectBrowser();
    this.detectOS();
    this.restrictedPorts = {
            Chrome: [1,7,9,11,13,15,17,19,20,21,22,23,25,37,42,43,53,77,79,87,95,101,102,103,104,109,110,111,113,115,117,119,123,135,139,143,179,389,465,512,513,514,515,526,530,531,532,540,556,563,587,601,636,993,995,2049,3659,4045,6000,6665,6666,6667,6668,6669,6697,65535],
            Firefox: [1,7,9,11,13,15,17,19,20,21,22,23,25,37,42,43,53,77,79,87,95,101,102,103,104,109,2,110,3,111,113,115,117,119,123,135,139,143,2,179,389,465,512,513,514,515,526,530,531,532,540,556,563,587,601,636,993,995,3,2049,4045,6000],
            Edge: [19, 21, 25, 110, 119, 143, 220, 993, ],
            Safari: [1,7,9,11,13,15,17,19,20,21,22,23,25,37,42,43,53,77,79,87,95,101,102,103,104,109,110,111,113,115,117,119,123,135,139,143,179,389,465,512,513,514,515,526,530,531,532,540,556,563,587,601,636,993,995,2049,3659,4045,6000,6665,6666,6667,6668,6669,6697,65535]};
  }
  setUrl(url) {
    this.url = url;
  }
  detectOS() {
    if(/Mac/i.test(navigator.platform)){
      this.os = "Mac";
    } else if(/Linux/i.test(navigator.platform)){
      this.os = "Linux";
    } else if(/^Win/i.test(navigator.platform)){
      this.os = "Windows";
    }
  }
  detectBrowser() {
      var isFirefox = typeof InstallTrigger !== 'undefined';
      if (isFirefox) {
          this.browser = 'Firefox';
      }
      else {
          this.browser = /Google/i.test(navigator.vendor)?'Chrome':/Apple/i.test(navigator.vendor)?'Safari':[].toSource?'Firefox':top.msCredentials?'Edge':'Unsupported';
      }
  }
  getCommonHttpPorts() {
    return [66,80,81,443,445,457,1080,1100,1241,1352,1337,1433,1434,1521,1944,2301,3000,3128,3306,4000,4001,4002,4100,5000,5432,5800,5801,5802,6346,6347,7001,7002,8000,8080,8888,30821].filter(x=>!~this.restrictedPorts[this.browser].indexOf(x));
  }
  getCommonPorts() {
    const portsVNCWeb = [5800, 5801, 5802, 5803, 5804, 5805, 5806];
    const portsVNC = [5900, 5901, 5902, 5903, 5904, 5905, 5906];
    const portsNoMachine = [4000, 4080, 4443];
    const portsWeb = [80, 443, 8080, 8000];
    const portsWinSystem = [135, 445, 3389, 5985];
    const portSSH = 22;
    const portTelnet = 23;
    const portTorrent = 6900;
    const portLiteManager = 5650;
    const portTeamViewer = 5938;

    const portsWin = [].concat(portsVNCWeb)
        .concat(portsVNC)
        .concat(portsNoMachine)
        .concat(portsWeb)
        .concat(portsWinSystem)
        .concat(portTorrent)
        .concat(portLiteManager)
        .concat(portTeamViewer);

    const portsMac = [].concat(portsWeb)
        .concat(portSSH)
        .concat(portTelnet)
        .concat(portsVNCWeb)
        .concat(portsVNC)
        .concat(portTeamViewer);

    return portsWin.filter(x=>!~this.restrictedPorts[this.browser].indexOf(x));
  }

  updateProgress(port) {
    this.progress.innerText = 'Проверяем порт ' + this.url.replace(/^http:\/\//,"") + ':' + port + ' ('+this.pos + ' из ' + this.total + ')';
  }
  next() {
    if(this.q.length) {
      this.pos++;
      this.scan();
      return true;
    } else {
      this.complete();
      return false;
    }
  }
  complete() {
        document.getElementById('spinner').remove();

        if(this.openPorts.length) {
          this.progress.innerText = "Найдены открытые порты: "+this.openPorts+' на хосте '+this.url.replace(/^http:\/\//,"");
        } else {
            this.progress.innerText = "Ничего не найдено";
//           this.progress.remove();
        }
        if(this.hooks && this.hooks.oncomplete) {
          this.hooks.oncomplete();
        }
  }
  async scanChromeWindows() {
    var that = this;
    let promise = new Promise(function(resolve,reject){
        that.hooks = {oncomplete:function(){
          var iframes = document.getElementsByClassName('chrome');
          while(iframes.length > 0){
            iframes[0].parentNode.removeChild(iframes[0]);
          }
          resolve();
        }};
        that.scan = function(){
          var port = that.q.shift(), id = 'chrome'+(that.pos%500), iframe = document.getElementById(id) ? document.getElementById(id) : document.createElement('iframe'), timer, calls = 0;
          iframe.style.display = 'none';
          iframe.id = iframe.name = id;
          iframe.src = that.url + ":" + port;
          iframe.className = 'chrome';
          that.updateProgress(port);
          iframe.hasLoadedOnce = 0;
          iframe.onload = function(){
            calls++;
            if(calls > 1) {
              clearTimeout(timer);
              that.next();
              return;
            }
            iframe.hasLoadedOnce = 1;
            var a = document.createElement('a');
              a.target = iframe.name;
              a.href = iframe.src + '#';
              a.click();
              a = null;
          };
          timer = setTimeout(function(){
            if(iframe.hasLoadedOnce) {
              that.openPorts.push(port);
            }
            if(that.connections <= that.maxConnections) {
              that.next();
              that.connections++;
            }
          }, 2000);
          if(!document.body.contains(iframe)) {
            document.body.appendChild(iframe);
          }
        };
        that.scan();
    });
    return promise;
  }
  async scanEdge() {
    var that = this;
    let promise = new Promise(function(resolve, reject){
      that.hooks = {oncomplete:function(){
        var iframes = document.getElementsByClassName('edge');
        while(iframes.length > 0){
          iframes[0].parentNode.removeChild(iframes[0]);
        }
        resolve();
      }};
      that.scan = function(){
        var port = that.q.shift(), id = 'edge'+(that.pos%50), iframe = document.getElementById(id) ? document.getElementById(id) : document.createElement('iframe'), calls = 0;
        iframe.style.display = 'none';
        iframe.id = iframe.name = id;
        iframe.src = that.url + ":" + port;
        iframe.className = 'edge';
        that.updateProgress(port);
        iframe.hasLoadedOnce = 0;
        iframe.onload = function(){
          calls++;
          if(calls > 1) {
            that.openPorts.push(port);
            that.next();
            return;
          }
          iframe.hasLoadedOnce = 1;
          var a = document.createElement('a');
            a.target = iframe.name;
            a.href = 'ms-appx-web://microsoft.microsoftedge/assets/errorpages/dnserror.html#123';
            a.click();
            a = null;
            if(calls == 1) {
              that.next();
            }
        };
        if(!document.body.contains(iframe)) {
          document.body.appendChild(iframe);
        }
      };
      that.scan();
    });
    return promise;
  }
  async scanFirefox() {
    var that = this;
    let promise = new Promise(function(resolve,reject){
        that.hooks = {oncomplete:function(){
          var iframes = document.getElementsByClassName('firefox');
          while(iframes.length > 0){
            iframes[0].parentNode.removeChild(iframes[0]);
          }
          resolve();
        }};
        that.scan = function(){
          var port = that.q.shift(), id = 'firefox'+(that.pos%1000), iframe = document.getElementById(id) ? document.getElementById(id) : document.createElement('iframe'), timer;
          iframe.style.display = 'none';
          iframe.id = id;
          iframe.src = that.url + ":" + port;
          iframe.className = 'firefox';
          that.updateProgress(port);
          iframe.onload = function(){
              that.openPorts.push(port);
              clearTimeout(timer);
              that.next();
          };
          timer = setTimeout(function(){
            that.next();
          }, 100);
          if(!document.body.contains(iframe)) {
            document.body.appendChild(iframe);
          }
        };
        that.scan();
    });
    return promise;
  }
  async scanChromeLinux(iframe, a) {
    var that = this;
    let promise = new Promise(function(resolve, reject){
        that.hooks = {oncomplete:function(){
          document.body.removeChild(iframe);
          resolve();
        }};
        that.scan = function() {
            var port = that.q.shift(), calls = 0, timer;
            console.log("Scan", port);
            iframe.src = that.url + ":" + port;
            console.log(iframe.src);
            a.href = iframe.src + '#';
            that.updateProgress(port);
            iframe.hasLoadedOnce = 0;
            iframe.onload = function(){
                calls++;
                console.log("onload", calls);
                if(calls > 1) {
                    console.log('clearTimer')
                  clearTimeout(timer);
                  that.next();
                  return;
                }
                iframe.hasLoadedOnce = 1;
                a.click();
            };
            timer = setTimeout(function(){
              if(iframe.hasLoadedOnce) {
                that.openPorts.push(port);
              }
              that.next();
            }, 1000);
        };
        that.scan();
    });
    return promise;
  }
  async scanArray(ports) {
      ports = ports.filter(x=>!~this.restrictedPorts[this.browser].indexOf(x));
      var that = this;
      let promise = new Promise(async function(resolve,reject){
          that.openPorts = [];
          that.closedPorts = [];
          that.pos = 1;
          that.q = ports.slice();
          that.total = that.q.length;
          that.progress = document.getElementById('check');
          if((that.os === 'Mac' || that.os === 'Linux') && (that.browser === 'Chrome' || that.browser === 'Safari')) {
            let iframe = document.createElement('iframe'), a = document.createElement('a');
            iframe.style.display = 'none';
            iframe.name = a.target = 'probe'+Date.now();
            document.body.appendChild(iframe);
            await that.scanChromeLinux(iframe, a);
          } else if(that.browser === 'Firefox') {
            await that.scanFirefox();
          } else if(that.browser === 'Edge') {
            await that.scanEdge();
          } else if(that.os === 'Windows' && (that.browser === 'Chrome' || that.browser === 'Safari')) {
            that.connections = 0;
            that.maxConnections = 150;
            await that.scanChromeWindows();
          }
          resolve();
      });
      return promise;
  }
  async scanRange(start, end) {
    const length = end - start;
    return await this.scanArray(Array.from({ length }, (_, i) => start + i));
  }
  async scanPort(port) {
    return await this.scanArray([port]);
  }
  getIPRange(ip) {
    let ipParts = ip.split('.'), ranges = [];
    ipParts.pop();
    for(let i=1;i<=254;i++) {
      ranges.push(ipParts.join('.')+'.'+i);
    }
    return ranges;
  }
  async getLocalIPs(){
      let promise = new Promise(function(resolve, reject){
        var ip_dups = {};
        var RTCPeerConnection = window.RTCPeerConnection
            || window.mozRTCPeerConnection
            || window.webkitRTCPeerConnection;
        var useWebKit = !!window.webkitRTCPeerConnection;
        if(!RTCPeerConnection){
            var win = document.querySelector('.iframe_webrtc').contentWindow;
            RTCPeerConnection = win.RTCPeerConnection
                || win.mozRTCPeerConnection
                || win.webkitRTCPeerConnection;
            useWebKit = !!win.webkitRTCPeerConnection;
        }
        var mediaConstraints = {
            optional: [{RtpDataChannels: true}]
        };
        var servers = {iceServers: [{urls: "stun:stun.services.mozilla.com"}]};
        if(!RTCPeerConnection) {
          reject();
          return;
        }
        var pc = new RTCPeerConnection(servers, mediaConstraints);
        function handleCandidate(candidate){
            var ip_regex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/
            var ip_addr = ip_regex.exec(candidate)[1];
            if(ip_dups[ip_addr] === undefined)
                resolve(ip_addr)
            ip_dups[ip_addr] = true;
        }
        pc.onicecandidate = function(ice){
            if(ice.candidate)
                handleCandidate(ice.candidate.candidate);
        };
        pc.createDataChannel("");
        pc.createOffer(function(result){
            pc.setLocalDescription(result, function(){}, function(){});

        }, function(){});
        setTimeout(function(){
            var lines = pc.localDescription.sdp.split('\n');
            lines.forEach(function(line){
                if(line.indexOf('a=candidate:') === 0)
                    handleCandidate(line);
            });
        }, 1000);
    });
    return promise;
  }
}
(async () =>{
  var scan = new PortScanner(), ip, ips, i;
  try {
      scan.setUrl('http://127.0.0.1');
      await scan.scanArray(scan.getCommonPorts());
    // // ip = await scan.getLocalIPs();
    // if (ip.match(/^(192\.168\.|169\.254\.|10\.|172\.(1[6-9]|2\d|3[01]))/)) {
    //   scan.setUrl('http://127.0.0.1');
    //   await scan.scanArray(scan.getCommonPorts());
    //   ips = scan.getIPRange(ip);
    //   for(i=0;i<ips.length;i++) {
    //     scan.setUrl('http://'+ips[i]);
    //     if(scan.browser === 'Firefox') {
    //       await scan.scanArray(scan.getCommonHttpPorts());
    //     } else {
    //       await scan.scanPort(80);
    //     }
    //   }
    //   scan.setUrl('http://'+ip);
    //   await scan.scanArray(scan.getCommonPorts());
    //   for(i=0;i<ips.length;i++) {
    //     if(ip === ips[i]) {
    //       continue;
    //     }
    //     scan.setUrl('http://'+ips[i]);
    //     await scan.scanArray(scan.getCommonPorts());
    //   }
    // } else {
    //   scan.setUrl('http://127.0.0.1');
    //   await scan.scanArray(scan.getCommonPorts());
    // }
  } catch(e){
    scan.setUrl('http://127.0.0.1');
    await scan.scanArray(scan.getCommonPorts());
  }
  // scan.setUrl('http://127.0.0.1');
  // for(i=0;i<=0xffff;i+=1000){
  //   await scan.scanRange(i,i+1000>0xffff?i+(0xffff-i):i+1000);
  // }
})();
</script>

    </div>
</main>


<!-- JavaScript Bundle with Popper -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4"
        crossorigin="anonymous"></script>
</body>
</html>
